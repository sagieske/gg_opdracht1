/* Computer Graphics, Assignment 1, Bresenham's Midpoint Line-Algorithm
 *
 * Filename ........ mla.c
 * Description ..... Midpoint Line Algorithm
 * Created by ...... Jurgen Sturm 
 *
 * Student name .... Sharon Gieske & Ysbrand Galama
 * Student email ... sharongieske@gmail.com & y.galama@hotmail.com
 * Collegekaart .... 6167667 & 10262067
 * Date ............ 8/02/2013
 * Comments ........
 *
 *
 * (always fill in these fields before submitting!!)
 */

#include "SDL.h"   
#include "init.h"

/*
 * Midpoint Line Algorithm
 *
 * As you probably will have figured out, this is the part where you prove
 * your programming skills. The code in the mla function should draw a direct 
 * line between (x0,y0) and (x1,y1) in the specified color. 
 * 
 * Until now, the example code below draws only a horizontal line between
 * (x0,y0) and (x1,y0) and a vertical line between (x1,y1).
 * 
 * And here the challenge begins..
 *
 * Good luck!
 *
 *
 */

/* Swap function to swap a and b using pointers. Function used for integers.
*/
void swap_int(int* a,int* b)
{
	int t=*a;
	*a=*b;
	*b=t;
}

/* Swap function to swap a and b using pointers. Function used for doubles.
*/
void swap_double(double* a,double* b)
{
	double t=*a;
	*a=*b;
	*b=t;
}

void mla(SDL_Surface *s, int x0, int y0, int x1, int y1, Uint32 colour) {
	int dx,dy,d,incry,incre,incrne,slopegt1=0;
	dx=abs(x0-x1);dy=abs(y0-y1);
	if(dy>dx)
	{
		swap(&x0,&y0);
		swap(&x1,&y1);
		swap(&dx,&dy);
		slopegt1=1;
	}
	if(x0>x1)
	{
		swap(&x0,&x0);
		swap(&y0,&y1);
	}
	if(y0>y1)
		incry=-1;
	else
		incry=1;
	d=2*dy-dx;
	incre=2*dy;
	incrne=2*(dy-dx);
	while(x0<x1)
	{
		if(d<=0)
			d+=incre;
		else
		{
			d+=incrne;
			y1+=incry;
		}
		x1++;
		if(slopegt1)
			putpixel(y0,x0,colour);
		else
			putpixel(x0,y0,colour);
	}	
	/*
	double x,y;
	double dx, dy;
	double diff; 
	double sign;

	// if x0 higher than x1, swap points
	if(x0 > x1){
		swap_int(&x0, &x1);
		swap_int(&y0, &y1);
	}

	// Difference between points in x and y direction
	dx = x1 - x0;
	dy = y1 - y0;

	// Slope
	diff = dy/dx;

	// set sign
	sign = 1;

	// Color end points of line
	PutPixel(s,x0,y0,colour);
	PutPixel(s,x1,y1,colour);
	
	// slope between -1 and inf
	if( (-1 <= diff && diff < 0) ||  (diff >= 0 && diff < 1 ) || (diff >=1)) {
		// flip over x-as		
		if (diff >= 1){
			swap_double(&x,&y);
			swap_int(&x0, &y0);
			swap_int(&x1, &y1);
			sign = -1;
		}	

		// take steps from x0,y0 to x1,y1				
		y = y0;
		for (x = x0; x<x1; ++x)
		{
			// flip sign when 0 <= slope < 1
			if(diff >= 0 && diff < 1 )
				sign = -1;

			// flip x, y coordinates for pixel drawing since x,y coordinates were swapt for formula
			if( diff >= 1)
				PutPixel(s,y,x,colour);
			else
				PutPixel(s,x,y,colour);

			double d = sign*((double)((y0-y1)*(x-1))+(double)(x1-x0)*(y+0.5)+(double)(x0*y1)-(double)(x1*y0));
			if (d > 0)
				y -= sign;
			if (d < 0 && diff > 1 )
				y += sign;
		}
	} 	
	//	slope between -inf and -1
	else {
		x = x0;
		for (y = y0; y>y1; --y)
		{
			PutPixel(s,x,y,colour);
			double d = ((double)((y0-y1)*(x-0.5))+(double)(x1-x0)*(y-1)+(double)(x0*y1)-(double)(x1*y0));
			if (d < 0)
				x++;
		}
	} */
	return;
}



